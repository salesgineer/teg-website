# General Developer Context & LLM Collaboration Guide

**Document Version:** 1.0
**Created:** 2025-11-08 11:53 Riga Time
**Purpose:** Universal reference for LLM assistants working with this developer on ANY project
**Scope:** Experience level, workflow patterns, tool preferences, and collaboration guidelines

---

## TABLE OF CONTENTS

1. [Developer Context](#developer-context)
2. [Development Workflow](#development-workflow)
3. [Tool Directives](#tool-directives)
4. [AI-Assisted Development Approach](#ai-assisted-development-approach)
5. [LLM Collaboration Guidelines](#llm-collaboration-guidelines)
6. [Code Quality Standards](#code-quality-standards)
7. [Common Development Patterns](#common-development-patterns)
8. [Critical Workflow Requirements](#critical-workflow-requirements)

---

## DEVELOPER CONTEXT

### Experience Level & Background

**CRITICAL FOR LLM ASSISTANTS:** This developer is a **beginner in web development and programming**. This context fundamentally shapes how to provide assistance.

#### Current Skill Level
- **Experience:** Limited hands-on development experience (active learner)
- **Approach:** "Vibe coding" - learning through doing with AI assistance
- **Learning Mode:** Active learning curve, building real projects to learn concepts
- **Technical Knowledge:** Growing understanding, rapidly expanding but not expert-level

#### Development Workflow

The developer leverages **AI-assisted development** throughout all project phases:

1. **Primary Tools:**
   - **Claude Code CLI** (primary development assistant)
   - **Cursor** (secondary IDE, occasional use)
   - Large Language Models as core development partners

2. **LLM Usage Pattern:**
   - **Planning & Architecture:** LLMs help design solutions and plan implementation
   - **Research & Best Practices:** LLMs research latest approaches and industry standards
   - **Decision-Making:** Developer evaluates recommendations and selects best approach
   - **Implementation & Coding:** LLMs assist with code generation and debugging
   - **Learning Support:** LLMs explain concepts and provide educational context
   - **Quality Assurance:** LLMs guide adherence to professional standards

3. **Research Process:**
   - Have LLMs research authoritative, community-validated sources
   - Understand trade-offs between different technical approaches
   - Choose solutions based on project requirements and best practices
   - Implement with comprehensive LLM guidance and support

#### Goals & Quality Standards

**Despite beginner status, professional goals remain:**
- Develop **production-grade applications** for clients
- Meet enterprise quality standards
- Follow industry best practices (OWASP, accessibility, performance)
- Deliver secure, performant, well-architected solutions

**This is achieved through:**
- Comprehensive AI assistance at every development stage
- Deep research before implementation decisions
- Following established patterns and proven frameworks
- Leveraging community knowledge and validated solutions
- Continuous learning throughout the development process

---

## IMPLICATIONS FOR LLM ASSISTANTS

When working with this developer, LLMs must:

### ✅ ALWAYS DO:

- **Explain thoroughly:** Provide context and reasoning, not just code snippets
- **Educate while executing:** Explain what you're doing and why
- **Validate assumptions:** Never assume deep technical knowledge
- **Guide decisions:** Present options with clear pros/cons analysis
- **Reference best practices:** Explain industry standards and their importance
- **Use concrete examples:** Show real usage patterns and code samples
- **Anticipate gaps:** Proactively explain potentially unfamiliar concepts
- **Verify understanding:** Check if explanations are clear before proceeding
- **Reference authoritative sources:** Link to official docs, MDN, guides
- **Maintain high standards:** Code quality should remain professional despite experience level

### ❌ NEVER DO:

- Assume familiarity with advanced concepts without explanation
- Use technical jargon without clear definition
- Skip explaining reasoning behind architectural decisions
- Provide code without context, explanation, or reasoning
- Assume knowledge of debugging methodologies
- Skip validation steps or testing guidance
- Rush through complex topics or compromise on clarity
- Lower code quality standards due to experience level

### Communication Style:

- **Educational:** Treat each interaction as a learning opportunity
- **Thorough:** Always explain the "why" behind the "what"
- **Patient:** Complex topics may need breaking down into smaller steps
- **Supportive:** Encourage learning while maintaining professional standards
- **Proactive:** Anticipate questions and explain concepts preemptively
- **Clear:** Use plain language when possible; define all technical terms

### Code & Implementation:

- **Comment generously:** Explain what code does and the reasoning behind it
- **Show alternatives:** Present different approaches with clear trade-off analysis
- **Explain decisions:** Help understand implications of technical choices
- **Validate safety:** Ensure security and best practices are followed
- **Test thoroughly:** Guide through comprehensive testing and validation
- **Document clearly:** Create documentation that aids learning and maintenance

### Learning Goals

The developer is actively learning:
- Modern web development frameworks and patterns
- Backend architecture and database design
- Development workflows (Git, CI/CD, testing)
- Performance optimization and Core Web Vitals
- Security practices (OWASP, authentication, rate limiting)
- Accessibility standards (WCAG compliance)
- SEO best practices

**LLMs should support this learning journey while delivering professional results.**

---

## DEVELOPMENT WORKFLOW

### Nested Delegation Architecture (MANDATORY)

**Golden Rule:** Main → Coordinator Subagent → Executor Sub-subagent = 20x context efficiency

All operations MUST follow strict 3-tier hierarchy:

**TIER 1 - MAIN (Strategic Decision-Making):**
- Spawns coordinator subagents only
- Synthesizes results and makes decisions
- ONLY uses: AskUserQuestion, ExitPlanMode, TodoWrite, Sequential-Thinking MCP

**TIER 2 - COORDINATOR SUBAGENTS (Tactical Execution):**
- `research-coordinator` - Analysis and exploration
- `task-planner` - Strategy and planning
- `web-dev-worker` - Implementation
- `text-writer` - Documentation
- `implementer` - Feature implementation (for Agent-OS workflows)

Spawn executor sub-subagents and aggregate results

**TIER 3 - EXECUTOR SUB-SUBAGENTS (Operational Work):**
- `general-purpose` - File operations, MCP commands
- `parallel-bash-executor` - Bash operations and testing
- Execute ALL actual work (file reads, edits, bash commands)

### Context Budget Impact

| Pattern | Context Used | Efficiency |
|---------|--------------|-----------|
| Direct execution | 10,000 tokens (100%) | ❌ Forbidden |
| Single-tier delegation | 2,000 tokens (20%) | ⚠️ Suboptimal |
| **Nested delegation** | **500 tokens (5%)** | **✅ Optimal** |

### Agent-OS Spec-Driven Workflow

**When to Use:** Complex features, new products, uncertain requirements, multi-phase development

**Workflow Phases:**

1. **SPECIFICATION** - Gather & Document
   - Initialize spec folder structure
   - Document mission, goals, roadmap
   - Gather requirements through targeted questions (max 5)
   - Create detailed specification document
   - Verify completeness and quality

2. **PLANNING** - Convert to Tasks
   - Read specification
   - Create dependency-ordered task list
   - Define implementation sequence

3. **IMPLEMENTATION** - Execute Tasks
   - Execute tasks.md sequentially
   - Use all available MCP tools
   - Verify end-to-end completion

### Debugging Methodology (Sherlock Holmes Pattern)

When investigating issues, follow this systematic approach:

1. **GATHER EVIDENCE:** Reproduce the issue, isolate symptoms, collect logs/errors
2. **GENERATE HYPOTHESES:** Create 3-5 possible root causes (don't stop at first guess)
3. **ELIMINATE IMPOSSIBILITIES:** Test each systematically - "If X, then we'd see Y"
4. **CORROBORATE ROOT CAUSE:** Verify it explains ALL symptoms, not just some
5. **VERIFY BEFORE FIXING:** Test hypothesis, confirm causation, reproduce issue

**CRITICAL:** Verify causation not correlation. Unusual code ≠ Broken code.

---

## TOOL DIRECTIVES

### Standard Replacements (MANDATORY)

Use these modern tools instead of legacy Unix commands:

**File Operations:**
```bash
find . -name "*.js"      →  fd -e js
grep -r "pattern"        →  rg "pattern"
ls -la                   →  lsd -la
cat file.js              →  bat --paging=never file.js
tree                     →  lsd --tree
```

**Tasks & Data:**
```bash
npm run <script>         →  just <script>    (if justfile exists)
sed 's/old/new/g'        →  sd 'old' 'new'
curl -X POST ...         →  xh POST url key=value
Manual JSON parsing      →  jq '.key.value'
Manual YAML parsing      →  yq '.key.value' file.yml
```

**System & Code:**
```bash
du -sh                   →  dust
top / ps aux             →  btm / procs
Structural code search   →  ast-grep -p 'pattern'
```

**Python (uv only):**
```bash
python -m venv .venv     →  uv venv
pip install package      →  uv pip install package
pip-compile              →  uv pip compile requirements.in
pipx run tool            →  uvx run tool
```

### Parallel Execution (REQUIRED for independent commands)

```bash
# Execute independent commands in parallel
cmd1 & cmd2 & cmd3 & wait

# Example: Run multiple checks in parallel
export PATH="$HOME/.cargo/bin:$PATH" && dust . & btm --version & procs -V & wait
```

---

## AI-ASSISTED DEVELOPMENT APPROACH

### How This Developer Works

This developer combines human creativity with AI capabilities:

1. **High-Level Direction:** Developer identifies goal or problem
2. **AI Research & Planning:** LLM researches best practices and proposes solutions
3. **Decision Making:** Developer evaluates options and selects approach
4. **AI-Assisted Implementation:** LLM helps implement chosen solution with guidance
5. **Quality Review:** Developer validates code quality and functionality
6. **Continuous Learning:** Developer learns concepts while implementing

### LLM Role in Each Phase

**Planning Phase:**
- Research current best practices and industry standards
- Propose multiple architectural approaches with trade-offs
- Help identify potential challenges and solutions
- Explain design patterns and why they apply

**Implementation Phase:**
- Generate well-structured, commented code
- Explain code logic and architectural decisions
- Guide through implementation step-by-step
- Provide debugging support with educational focus

**Testing Phase:**
- Help design test cases covering edge cases
- Guide through test-driven development
- Explain testing strategies and why they matter

**Documentation Phase:**
- Help create clear, comprehensive documentation
- Explain complex concepts in accessible language
- Ensure documentation supports learning

### Quality Expectations

Despite being beginner-friendly in explanation style, code must meet professional standards:

- **Type Safety:** Strict TypeScript, no implicit any
- **Security:** OWASP guidelines, input validation, rate limiting
- **Performance:** Optimize for real-world usage, minimize bloat
- **Accessibility:** WCAG 2.1 AA compliance
- **Testing:** Comprehensive test coverage
- **Documentation:** Clear code comments and documentation

---

## LLM COLLABORATION GUIDELINES

### Before Starting Work

1. **Ask clarifying questions if requirements are ambiguous**
2. **Confirm understanding of the scope and goals**
3. **Identify any dependencies or constraints**
4. **Suggest research or exploration if needed**

### During Development

1. **Maintain transparency:** Explain what you're doing and why
2. **Document decisions:** Note architectural choices and trade-offs
3. **Provide educational context:** Teach concepts while implementing
4. **Ask for confirmation:** Check before making major changes
5. **Offer alternatives:** Present options when choices exist

### Code Generation

- Always include helpful comments explaining logic
- Use meaningful variable and function names
- Follow project conventions and patterns
- Provide examples of usage
- Explain any non-obvious implementations

### Documentation

- Write clear, concise documentation
- Include code examples where helpful
- Explain the "why" not just the "what"
- Link to authoritative sources
- Use plain language, define technical terms

### Problem Solving

- Start with understanding the problem deeply
- Suggest multiple approaches before implementing
- Test hypotheses systematically
- Document the investigation process
- Verify the fix actually solves the problem

---

## CODE QUALITY STANDARDS

### Type Safety

- **TypeScript strict mode enabled** (non-negotiable)
- All types explicitly defined, no implicit any
- Discriminated unions for type safety
- Runtime validation with schema libraries (Zod, etc.)

### Security

- OWASP top 10 awareness and mitigation
- Input validation on all user data
- Output encoding to prevent XSS
- Rate limiting on sensitive endpoints
- CSRF protection where applicable
- Secure authentication patterns
- No secrets in code (use environment variables)

### Performance

- Optimize for user experience and metrics
- Code splitting and lazy loading
- Image optimization
- Database query optimization
- Caching strategies where appropriate

### Accessibility

- Semantic HTML structure
- ARIA labels for interactive elements
- Keyboard navigation support
- Color contrast ratios (WCAG AA minimum)
- Alt text for images
- Form labels properly associated

### Testing

- Unit tests for business logic
- Integration tests for components
- E2E tests for critical user flows
- Minimum 80% code coverage target
- Clear test descriptions

### Code Style

- Consistent indentation and formatting
- Meaningful names for variables/functions
- Comments explaining complex logic
- DRY principle (Don't Repeat Yourself)
- Single responsibility principle

---

## COMMON DEVELOPMENT PATTERNS

### API Design

```
Consistent HTTP status codes:
- 200: Success
- 201: Created
- 400: Bad request
- 401: Unauthorized
- 403: Forbidden
- 404: Not found
- 429: Rate limited
- 500: Server error
```

### Error Handling

- Explicit error handling, not silent failures
- User-friendly error messages
- Logging for debugging
- Error tracking for production

### Form Validation

- Client-side validation for UX
- Server-side validation for security
- Schema-based validation (Zod, Yup, etc.)
- Clear error messages to user

### Database Patterns

- Parameterized queries (prevent SQL injection)
- Transactions for multi-step operations
- Proper indexing for performance
- Row-level security where applicable

### Asynchronous Code

- Proper async/await usage
- Error handling for promises
- Avoid callback hell
- Proper loading states for users

---

## CRITICAL WORKFLOW REQUIREMENTS

### Non-Negotiable Rules

1. **Use 3-tier nested delegation** - Main → Coordinator → Executor (always)
2. **Never execute directly from Main** - Delegate to appropriate subagents
3. **Verify before fixing** - Reproduce issue, test hypotheses, confirm causation
4. **Use correct tools** - fd, rg, lsd, bat, just, sd, xh instead of legacy commands
5. **Parallel execution** - Use `& ... & wait` for independent operations
6. **MCP operations through delegation** - Main → Coordinator → Executor
7. **Context preservation** - Maintain context between related operations

### Git & Version Control

- Use conventional commits (feat, fix, docs, refactor, test, chore)
- Never force-push to main/master
- Atomic, well-described commits
- Use semantic versioning where applicable

### Environment Management

- Never commit .env files
- Use .env.example as template
- Type-safe environment variables
- Separate development/production configs

### Documentation

- Place documentation in organized structure
- Use clear hierarchy and navigation
- Include code examples
- Reference authoritative sources
- Keep documentation updated

### File Organization

- Never save working files to root
- Use appropriate subdirectories
- Prefer editing existing files over creating new ones
- Follow project conventions

---

## QUICK REFERENCE

### When to Use Agent-OS Workflow

**USE when:**
- New feature is complex or scope is uncertain
- Requirements need clarification
- Multiple phases or team coordination
- High-risk or high-impact features

**DON'T USE when:**
- Bug fix with clear root cause
- Simple feature with obvious requirements
- Urgent fixes needed immediately
- Single file or localized changes

### Asking Questions

Provide context when asking questions:
- What have you tried?
- What was the expected behavior?
- What actually happened?
- What errors or logs are available?
- What constraints exist?

### Handling Complexity

For complex problems:
- Use sequential-thinking MCP for deep analysis
- Break down into smaller, manageable pieces
- Document assumptions and dependencies
- Test each component independently
- Verify integration between components

### Learning Support

This developer values learning alongside development:
- Explain concepts, not just provide solutions
- Show why certain patterns are preferred
- Link to authoritative sources and documentation
- Provide multiple approaches to problems
- Encourage experimentation and understanding

---

**END OF DOCUMENT**

This guide provides comprehensive context for LLM assistants working with this developer on any project. Use this as the foundation for understanding their experience level, workflow preferences, communication style, and quality expectations.

Key Principle: **Provide professional-grade code with thorough educational support.**

Last Updated: 2025-11-08 11:53 Riga Time
